/* eslint-disable react-hooks/exhaustive-deps */
import { useEffect, useCallback } from 'react';
import { runOnJS, useSharedValue, withSpring, withTiming, withDelay } from 'react-native-reanimated';
import { PanningDirectionsEnum, DEFAULT_ANIMATION_CONFIG } from "../panView";
import useAnimationEndNotifier, { TransitionViewAnimationType } from "./useAnimationEndNotifier";
const TransitionViewDirectionEnum = PanningDirectionsEnum;
export { TransitionViewAnimationType, TransitionViewDirectionEnum };
const ENTER_ANIMATION_CONFIG = DEFAULT_ANIMATION_CONFIG;
const EXIT_ANIMATION_CONFIG = {
  duration: 300
};
export default function useAnimatedTransition(props) {
  const {
    hiddenLocation,
    enterFrom,
    exitTo,
    onAnimationStart,
    onAnimationEnd,
    delay
  } = props;

  // Has to start at {0, 0} with {opacity: 0} so layout can be measured
  const translationX = useSharedValue(0);
  const translationY = useSharedValue(0);
  const {
    onEnterAnimationEnd,
    onExitAnimationEnd
  } = useAnimationEndNotifier({
    onAnimationEnd
  });
  const isMounted = useSharedValue(false);
  const getLocation = direction => {
    return {
      x:
      //@ts-expect-error
      direction && [TransitionViewDirectionEnum.LEFT, TransitionViewDirectionEnum.RIGHT].includes(direction) ? hiddenLocation[direction] : 0,
      y:
      //@ts-expect-error
      direction && [TransitionViewDirectionEnum.UP, TransitionViewDirectionEnum.DOWN].includes(direction) ? hiddenLocation[direction] : 0
    };
  };
  const onHiddenLocationUpdated = useCallback(() => {
    'worklet';

    const to = getLocation(enterFrom);
    // @ts-expect-error
    if ([TransitionViewDirectionEnum.LEFT, TransitionViewDirectionEnum.RIGHT].includes(enterFrom)) {
      translationX.value = withTiming(to.x, {
        duration: 0
      }, animateIn);
      // @ts-expect-error
    } else if ([TransitionViewDirectionEnum.UP, TransitionViewDirectionEnum.DOWN].includes(enterFrom)) {
      translationY.value = withTiming(to.y, {
        duration: 0
      }, animateIn);
    }
    if (!isMounted.value) {
      isMounted.value = true;
    }
  }, []);
  useEffect(() => {
    if (hiddenLocation.wasMeasured && enterFrom) {
      onHiddenLocationUpdated();
    }
  }, [hiddenLocation]);
  const translateTo = useCallback((to, animation, animationConfig, animationDirection, callback, delay = 0) => {
    'worklet';

    // @ts-expect-error
    if ([TransitionViewDirectionEnum.LEFT, TransitionViewDirectionEnum.RIGHT].includes(animationDirection)) {
      translationX.value = withDelay(delay, animation(to.x, animationConfig, callback));
      // @ts-expect-error
    } else if ([TransitionViewDirectionEnum.UP, TransitionViewDirectionEnum.DOWN].includes(animationDirection)) {
      translationY.value = withDelay(delay, animation(to.y, animationConfig, callback));
    }
  }, []);
  const animateIn = useCallback(() => {
    'worklet';

    if (enterFrom) {
      if (onAnimationStart) {
        runOnJS(onAnimationStart)('enter');
      }
      translateTo({
        x: 0,
        y: 0
      }, withSpring, ENTER_ANIMATION_CONFIG, enterFrom, onEnterAnimationEnd, delay?.enter);
    }
  }, [onEnterAnimationEnd, delay?.enter]);
  const animateOut = useCallback(() => {
    'worklet';

    if (exitTo) {
      if (onAnimationStart) {
        runOnJS(onAnimationStart)('exit');
      }
      translateTo(getLocation(exitTo), withTiming, EXIT_ANIMATION_CONFIG, exitTo, onExitAnimationEnd, delay?.exit);
    }
  }, [hiddenLocation, exitTo, onExitAnimationEnd, delay?.exit]);
  return {
    animateIn,
    animateOut,
    translation: {
      x: translationX,
      y: translationY
    },
    isMounted
  };
}